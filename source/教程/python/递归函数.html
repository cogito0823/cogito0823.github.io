<html>
<head>
  <title>递归函数</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600753 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1825"/>
<h1>递归函数</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2019/9/3 2:54</i></td></tr>
</table>
</div>
<br/>

<div><span>
  <div style="--en-clipped-content:article">
<div><br/></div><div style="font-size: 16px; display:block; min-width: 100%; position: relative;"> <div style="font:14px/20px &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;text-size-adjust:100%;background:rgb(255, 255, 255);color:rgb(68, 68, 68);"><div style="font-family:&quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;font-size:14px;line-height:20px;color:rgb(102, 102, 102);background-color:rgb(255, 255, 255);"><div><div style="box-sizing:border-box;"><div style="list-style:none;"><div style="box-sizing:border-box;"><div><div><div><div><p style="margin:0px 0px 15px;">在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</p>
<p style="margin:0px 0px 15px;margin-top:15px;">举个例子，我们来计算阶乘<code style="font-size:12px;font-family:Consolas, monospace, serif;color:rgb(221, 0, 85);padding:0px 4px;border:1px solid rgb(221, 221, 221);border-radius:3px;background:rgb(250, 250, 250);white-space:normal;">n! = 1 x 2 x 3 x ... x n</code>，用函数<code style="font-size:12px;font-family:Consolas, monospace, serif;color:rgb(221, 0, 85);padding:0px 4px;border:1px solid rgb(221, 221, 221);border-radius:3px;background:rgb(250, 250, 250);white-space:normal;">fact(n)</code>表示，可以看出：</p>
<p style="margin:0px 0px 15px;margin-top:15px;">fact(n) = n! = 1 x 2 x 3 x ... x (n-1) x n = (n-1)! x n = fact(n-1) x n</p>
<p style="margin:0px 0px 15px;margin-top:15px;">所以，<code style="font-size:12px;font-family:Consolas, monospace, serif;color:rgb(221, 0, 85);padding:0px 4px;border:1px solid rgb(221, 221, 221);border-radius:3px;background:rgb(250, 250, 250);white-space:normal;">fact(n)</code>可以表示为<code style="font-size:12px;font-family:Consolas, monospace, serif;color:rgb(221, 0, 85);padding:0px 4px;border:1px solid rgb(221, 221, 221);border-radius:3px;background:rgb(250, 250, 250);white-space:normal;">n x fact(n-1)</code>，只有n=1时需要特殊处理。</p>
<p style="margin:0px 0px 15px;margin-top:15px;">于是，<code style="font-size:12px;font-family:Consolas, monospace, serif;color:rgb(221, 0, 85);padding:0px 4px;border:1px solid rgb(221, 221, 221);border-radius:3px;background:rgb(250, 250, 250);white-space:normal;">fact(n)</code>用递归的方式写出来就是：</p>
<pre style="margin:0px 0px 15px;margin-top:15px;padding:10px;background:rgb(250, 250, 250);font:12px/18px Consolas, monospace, serif;color:rgb(68, 68, 68);tab-size:4;overflow:auto;border:1px solid rgb(221, 221, 221);border-radius:3px;"><code style="white-space:pre-wrap;"><span><span style="color:rgb(51, 51, 51);font-weight:bold;">def</span> <span style="color:rgb(153, 0, 0);font-weight:bold;">fact</span><span>(n)</span>:</span>
    <span style="color:rgb(51, 51, 51);font-weight:bold;">if</span> n==<span style="color:rgb(0, 153, 153);">1</span>:
        <span style="color:rgb(51, 51, 51);font-weight:bold;">return</span> <span style="color:rgb(0, 153, 153);">1</span>
    <span style="color:rgb(51, 51, 51);font-weight:bold;">return</span> n * fact(n - <span style="color:rgb(0, 153, 153);">1</span>)
</code></pre>
<p style="margin:0px 0px 15px;margin-top:15px;">上面就是一个递归函数。可以试试：</p>
<pre style="margin:0px 0px 15px;margin-top:15px;padding:10px;background:rgb(250, 250, 250);font:12px/18px Consolas, monospace, serif;color:rgb(68, 68, 68);tab-size:4;overflow:auto;border:1px solid rgb(221, 221, 221);border-radius:3px;"><code style="white-space:pre-wrap;"><span style="color:rgb(153, 0, 115);">&gt;&gt;&gt; </span>fact(<span style="color:rgb(0, 153, 153);">1</span>)
<span style="color:rgb(0, 153, 153);">1</span>
<span style="color:rgb(153, 0, 115);">&gt;&gt;&gt; </span>fact(<span style="color:rgb(0, 153, 153);">5</span>)
<span style="color:rgb(0, 153, 153);">120</span>
<span style="color:rgb(153, 0, 115);">&gt;&gt;&gt; </span>fact(<span style="color:rgb(0, 153, 153);">100</span>)
<span style="color:rgb(0, 153, 153);">93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</span>
</code></pre>
<p style="margin:0px 0px 15px;margin-top:15px;">如果我们计算<code style="font-size:12px;font-family:Consolas, monospace, serif;color:rgb(221, 0, 85);padding:0px 4px;border:1px solid rgb(221, 221, 221);border-radius:3px;background:rgb(250, 250, 250);white-space:normal;">fact(5)</code>，可以根据函数定义看到计算过程如下：</p>
<pre style="margin:0px 0px 15px;margin-top:15px;padding:10px;background:rgb(250, 250, 250);font:12px/18px Consolas, monospace, serif;color:rgb(68, 68, 68);tab-size:4;overflow:auto;border:none;border-radius:3px;font-size:12px;line-height:12px;white-space:pre;background-color:transparent;"><code style="white-space:pre-wrap;font-family:&quot;Courier New&quot;, Consolas, monospace;">===&gt; fact(5)
===&gt; 5 * fact(4)
===&gt; 5 * (4 * fact(3))
===&gt; 5 * (4 * (3 * fact(2)))
===&gt; 5 * (4 * (3 * (2 * fact(1))))
===&gt; 5 * (4 * (3 * (2 * 1)))
===&gt; 5 * (4 * (3 * 2))
===&gt; 5 * (4 * 6)
===&gt; 5 * 24
===&gt; 120
</code></pre>
<p style="margin:0px 0px 15px;margin-top:15px;">递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。</p>
<p style="margin:0px 0px 15px;margin-top:15px;">使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试<code style="font-size:12px;font-family:Consolas, monospace, serif;color:rgb(221, 0, 85);padding:0px 4px;border:1px solid rgb(221, 221, 221);border-radius:3px;background:rgb(250, 250, 250);white-space:normal;">fact(1000)</code>：</p>
<pre style="margin:0px 0px 15px;margin-top:15px;padding:10px;background:rgb(250, 250, 250);font:12px/18px Consolas, monospace, serif;color:rgb(68, 68, 68);tab-size:4;overflow:auto;border:1px solid rgb(221, 221, 221);border-radius:3px;"><code style="white-space:pre-wrap;">&gt;&gt;&gt; fact(1000)
Traceback (most recent call last):
  File &quot;<span style="color:rgb(0, 0, 128);font-weight:normal;">&lt;<span style="color:rgb(0, 0, 128);font-weight:normal;">stdin</span>&gt;</span>&quot;, line 1, in <span style="color:rgb(0, 0, 128);font-weight:normal;">&lt;<span style="color:rgb(0, 0, 128);font-weight:normal;">module</span>&gt;</span>
  File &quot;<span style="color:rgb(0, 0, 128);font-weight:normal;">&lt;<span style="color:rgb(0, 0, 128);font-weight:normal;">stdin</span>&gt;</span>&quot;, line 4, in fact
  ...
  File &quot;<span style="color:rgb(0, 0, 128);font-weight:normal;">&lt;<span style="color:rgb(0, 0, 128);font-weight:normal;">stdin</span>&gt;</span>&quot;, line 4, in fact
RuntimeError: maximum recursion depth exceeded in comparison
</code></pre>
<p style="margin:0px 0px 15px;margin-top:15px;">解决递归调用栈溢出的方法是通过<strong style="font-weight:bold;">尾递归</strong>优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</p>
<p style="margin:0px 0px 15px;margin-top:15px;">尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p>
<p style="margin:0px 0px 15px;margin-top:15px;">上面的<code style="font-size:12px;font-family:Consolas, monospace, serif;color:rgb(221, 0, 85);padding:0px 4px;border:1px solid rgb(221, 221, 221);border-radius:3px;background:rgb(250, 250, 250);white-space:normal;">fact(n)</code>函数由于<code style="font-size:12px;font-family:Consolas, monospace, serif;color:rgb(221, 0, 85);padding:0px 4px;border:1px solid rgb(221, 221, 221);border-radius:3px;background:rgb(250, 250, 250);white-space:normal;">return n * fact(n - 1)</code>引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</p>
<pre style="margin:0px 0px 15px;margin-top:15px;padding:10px;background:rgb(250, 250, 250);font:12px/18px Consolas, monospace, serif;color:rgb(68, 68, 68);tab-size:4;overflow:auto;border:1px solid rgb(221, 221, 221);border-radius:3px;"><code style="white-space:pre-wrap;"><span><span style="color:rgb(51, 51, 51);font-weight:bold;">def</span> <span style="color:rgb(153, 0, 0);font-weight:bold;">fact</span><span>(n)</span>:</span>
    <span style="color:rgb(51, 51, 51);font-weight:bold;">return</span> fact_iter(n, <span style="color:rgb(0, 153, 153);">1</span>)

<span><span style="color:rgb(51, 51, 51);font-weight:bold;">def</span> <span style="color:rgb(153, 0, 0);font-weight:bold;">fact_iter</span><span>(num, product)</span>:</span>
    <span style="color:rgb(51, 51, 51);font-weight:bold;">if</span> num == <span style="color:rgb(0, 153, 153);">1</span>:
        <span style="color:rgb(51, 51, 51);font-weight:bold;">return</span> product
    <span style="color:rgb(51, 51, 51);font-weight:bold;">return</span> fact_iter(num - <span style="color:rgb(0, 153, 153);">1</span>, num * product)
</code></pre>
<p style="margin:0px 0px 15px;margin-top:15px;">可以看到，<code style="font-size:12px;font-family:Consolas, monospace, serif;color:rgb(221, 0, 85);padding:0px 4px;border:1px solid rgb(221, 221, 221);border-radius:3px;background:rgb(250, 250, 250);white-space:normal;">return fact_iter(num - 1, num * product)</code>仅返回递归函数本身，<code style="font-size:12px;font-family:Consolas, monospace, serif;color:rgb(221, 0, 85);padding:0px 4px;border:1px solid rgb(221, 221, 221);border-radius:3px;background:rgb(250, 250, 250);white-space:normal;">num - 1</code>和<code style="font-size:12px;font-family:Consolas, monospace, serif;color:rgb(221, 0, 85);padding:0px 4px;border:1px solid rgb(221, 221, 221);border-radius:3px;background:rgb(250, 250, 250);white-space:normal;">num * product</code>在函数调用前就会被计算，不影响函数调用。</p>
<p style="margin:0px 0px 15px;margin-top:15px;"><code style="font-size:12px;font-family:Consolas, monospace, serif;color:rgb(221, 0, 85);padding:0px 4px;border:1px solid rgb(221, 221, 221);border-radius:3px;background:rgb(250, 250, 250);white-space:normal;">fact(5)</code>对应的<code style="font-size:12px;font-family:Consolas, monospace, serif;color:rgb(221, 0, 85);padding:0px 4px;border:1px solid rgb(221, 221, 221);border-radius:3px;background:rgb(250, 250, 250);white-space:normal;">fact_iter(5, 1)</code>的调用如下：</p>
<pre style="margin:0px 0px 15px;margin-top:15px;padding:10px;background:rgb(250, 250, 250);font:12px/18px Consolas, monospace, serif;color:rgb(68, 68, 68);tab-size:4;overflow:auto;border:1px solid rgb(221, 221, 221);border-radius:3px;"><code style="white-space:pre-wrap;">===&gt; fact_iter(<span style="color:rgb(0, 153, 153);">5</span>, <span style="color:rgb(0, 153, 153);">1</span>)
===&gt; fact_iter(<span style="color:rgb(0, 153, 153);">4</span>, <span style="color:rgb(0, 153, 153);">5</span>)
===&gt; fact_iter(<span style="color:rgb(0, 153, 153);">3</span>, <span style="color:rgb(0, 153, 153);">20</span>)
===&gt; fact_iter(<span style="color:rgb(0, 153, 153);">2</span>, <span style="color:rgb(0, 153, 153);">60</span>)
===&gt; fact_iter(<span style="color:rgb(0, 153, 153);">1</span>, <span style="color:rgb(0, 153, 153);">120</span>)
===&gt; <span style="color:rgb(0, 153, 153);">120</span>
</code></pre>
<p style="margin:0px 0px 15px;margin-top:15px;">尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。</p>
<p style="margin:0px 0px 15px;margin-top:15px;">遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的<code style="font-size:12px;font-family:Consolas, monospace, serif;color:rgb(221, 0, 85);padding:0px 4px;border:1px solid rgb(221, 221, 221);border-radius:3px;background:rgb(250, 250, 250);white-space:normal;">fact(n)</code>函数改成尾递归方式，也会导致栈溢出。</p>
<h3 style="margin:0px 0px 15px;font-family:&quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;font-weight:normal;color:rgb(68, 68, 68);text-transform:none;margin-top:25px;font-size:18px;line-height:24px;">小结</h3>
<p style="margin:0px 0px 15px;margin-top:15px;">使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。</p>
<p style="margin:0px 0px 15px;margin-top:15px;">针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。</p>
<p style="margin:0px 0px 15px;margin-top:15px;">Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。</p>
<h3 style="margin:0px 0px 15px;font-family:&quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;font-weight:normal;color:rgb(68, 68, 68);text-transform:none;margin-top:25px;font-size:18px;line-height:24px;">练习</h3>
<p style="margin:0px 0px 15px;margin-top:15px;"><a href="http://baike.baidu.com/view/191666.htm" style="background:transparent;color:rgb(5, 147, 211);text-decoration:none;cursor:pointer;" target="_blank">汉诺塔</a>的移动可以用递归函数非常简单地实现。</p>
<p style="margin:0px 0px 15px;margin-top:15px;">请编写<code style="font-size:12px;font-family:Consolas, monospace, serif;color:rgb(221, 0, 85);padding:0px 4px;border:1px solid rgb(221, 221, 221);border-radius:3px;background:rgb(250, 250, 250);white-space:normal;">move(n, a, b, c)</code>函数，它接收参数<code style="font-size:12px;font-family:Consolas, monospace, serif;color:rgb(221, 0, 85);padding:0px 4px;border:1px solid rgb(221, 221, 221);border-radius:3px;background:rgb(250, 250, 250);white-space:normal;">n</code>，表示3个柱子A、B、C中第1个柱子A的盘子数量，然后打印出把所有盘子从A借助B移动到C的方法，例如：</p>
<div style="margin-top:15px;margin-bottom:15px;"><pre style="margin:0px 0px 15px;padding:6px;background:rgb(250, 250, 250);font:12px/18px Consolas, monospace, serif;color:rgb(68, 68, 68);tab-size:4;overflow:auto;border:1px solid rgb(221, 221, 221);border-radius:3px;font-size:14px;margin-bottom:0px;border-bottom:none;border-bottom-left-radius:0px;border-bottom-right-radius:0px;"># -*- coding: utf-8 -*-
def move(n, a, b, c):
</pre><pre style="margin:0px 0px 15px;margin-top:0;padding:6px;background:rgb(250, 250, 250);font:12px/18px Consolas, monospace, serif;color:rgb(68, 68, 68);tab-size:4;overflow:auto;border:1px solid rgb(221, 221, 221);border-radius:3px;font-size:14px;border-top:0;border-top-left-radius:0;border-top-right-radius:0;"># 期待输出:
# A --&gt; C
# A --&gt; B
# C --&gt; B
# A --&gt; C
# B --&gt; A
# B --&gt; C
# A --&gt; C
move(3, 'A', 'B', 'C')
</pre></div>
<h3 style="margin:0px 0px 15px;font-family:&quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;font-weight:normal;color:rgb(68, 68, 68);text-transform:none;margin-top:25px;font-size:18px;line-height:24px;">参考源码</h3>
<p style="margin:0px 0px 15px;margin-top:15px;"><a href="https://github.com/michaelliao/learn-python3/blob/master/samples/function/recur.py" style="background:transparent;color:rgb(5, 147, 211);text-decoration:none;cursor:pointer;" target="_blank">recur.py</a></p>
</div></div></div></div></div></div></div></div></div></div></div>
</div>
</span>
</div></body></html> 